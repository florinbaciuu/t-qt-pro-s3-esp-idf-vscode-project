ComandÄƒ	FuncÈ›ie	Status
info tasks	Dump simplu cu vTaskList()	âœ”ï¸
tasks	Dump avansat cu load, etc.	âœ”ï¸
tasks --kill	TerminÄƒ un task	ğŸ’¥ to do
tasks --create	CreeazÄƒ un nou task	ğŸ’¥ to do
tasks --watch	Mod tip htop embedded	ğŸ’¥ to do


xTaskCreatePinnedToCore(
    my_task_function,
    "MyTask",
    2048,
    NULL,
    prio,
    NULL,
    core
);


tasks --kill <task_name>
FoloseÈ™ti vTaskDelete(handle) dupÄƒ ce gÄƒseÈ™ti taskul cu:

c
CopiazÄƒ
EditeazÄƒ
TaskHandle_t xHandle = xTaskGetHandle("MyTask");
Dar atenÈ›ie: xTaskGetHandle funcÈ›ioneazÄƒ doar dacÄƒ ai nume unic È™i setat corect. Altfel, trebuie sÄƒ-È›i È›ii tu o listÄƒ cu handle-uri.



âœ… tasks --suspend <name> / --resume <name>
Cu:

c
CopiazÄƒ
EditeazÄƒ
vTaskSuspend(xHandle);
vTaskResume(xHandle);


tasks --cpu-load
Rulezi tasks_info() avansat, cel cu load Ã®n procente, pe un interval dat. Eventual rulezi tasks monitor --watch ca un htop.

ğŸ”¨ ArhitecturÄƒ sugeratÄƒ
Ãn tasks.c poÈ›i avea:

c
CopiazÄƒ
EditeazÄƒ
typedef struct {
    const char* name;
    int (*handler)(int argc, char** argv);
    const char* desc;
} task_cli_command_t;

static task_cli_command_t task_commands[] = {
    { "list", tasks_info, "Show running tasks" },
    { "kill", task_kill, "Kill a task by name" },
    { "create", task_create, "Create a new task" },
    { "suspend", task_suspend, "Suspend task" },
    { "resume", task_resume, "Resume task" },
    { NULL, NULL, NULL }
};
È˜i Ã®n tasks_main(int argc, char** argv) faci dispatch pe argv[1].